using System;

namespace Test {
    class Program {
        static void Main(string[] args) {
            // Демонстрация полиморфизма через массив базового типа
            Console.WriteLine("Демонстрация полиморфизма через массив базового типа Mebel\n");

            // Создаем массив базового типа, но заполняем его объектами разных производных классов
            Mebel[] мебель = new Mebel[6];

            // Заполняем массив объектами разных типов (полиморфизм)
            мебель[0] = new Stol("Обеденный стол", 15000, Material.Дерево, 120, 80, 75);
            мебель[1] = new MyagkMebel("Диван", 25000, Material.Ткань, 3, true);
            мебель[2] = new Shkaf("Шкаф-купе", 30000, Material.Дерево, 200, 240, 60, 2);
            мебель[3] = new Stol("Компьютерный стол", 8000, Material.Металл, 100, 60, 75);
            мебель[4] = new MyagkMebel("Кресло", 12000, Material.Кожа, 1, true);
            мебель[5] = new Shkaf("Книжный шкаф", 18000, Material.Дерево, 100, 200, 40, 4);

            // Полиморфное поведение: вызов переопределенных методов
            Console.WriteLine("=== Вывод информации (полиморфизм) ===\n");
            for (int i = 0; i < мебель.Length; i++) {
                Console.WriteLine($">>>>>>>>>>> Тип: {мебель[i].GetType().Name}");
                Console.WriteLine($"Реальный тип (через GetType()): {мебель[i].GetType().Name}");
                Console.WriteLine($"Тип (через переопределенный метод): {мебель[i].ПолучитьТип()}");
                Console.WriteLine($"Полная информация (переопределенное свойство): {мебель[i].ПолнаяИнформация}");
                мебель[i].Info(); // Вызов переопределенного метода Info()
                Console.WriteLine($"Итоговая стоимость (переопределенный метод): {мебель[i].РассчитатьСтоимость():F2} руб.");
                Console.WriteLine("\n" + new string('-', 50) + "\n");
            }

            // Демонстрация полиморфного поведения при вызове виртуальных методов
            Console.WriteLine("\n=== Полиморфное поведение: вызов виртуальных методов ===\n");
            foreach (Mebel item in мебель) {
                // Полиморфизм: один и тот же вызов метода работает по-разному
                // в зависимости от реального типа объекта
                string тип = item.ПолучитьТип(); // Вызов переопределенного метода
                double стоимость = item.РассчитатьСтоимость(); // Вызов переопределенного метода
                string информация = item.ПолнаяИнформация; // Использование переопределенного свойства
                
                Console.WriteLine($"{тип}: {информация}");
                Console.WriteLine($"Стоимость: {стоимость:F2} руб.\n");
            }

            Console.WriteLine("\nПризнаки полиморфного поведения:");
            Console.WriteLine("1. Массив базового типа содержит объекты разных производных классов");
            Console.WriteLine("2. Вызов метода GetType() возвращает реальный тип объекта (не базовый)");
            Console.WriteLine("3. Переопределенные методы (Info, РассчитатьСтоимость, ПолучитьТип)");
            Console.WriteLine("   вызываются в зависимости от реального типа объекта");
            Console.WriteLine("4. Переопределенное свойство ПолнаяИнформация работает полиморфно");
            Console.WriteLine("5. Один и тот же код работает с разными типами объектов");

            Console.ReadKey();
        }
    }
}

